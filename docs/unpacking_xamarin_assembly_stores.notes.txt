================================
"assemblies.blob" file contents:
================================
20 = header
------------ for each LOCAL assembly (ie: DLL) file, sorted by `json_data.assemblies[n].blob_idx`:
24 = table of contents entry, which includes DataOffset and DataSize to extract DLL data from blob
------------ for each GLOBAL assembly (ie: DLL) file, sorted by `json_data.assemblies[n].hash32`:
20 = hash32
------------ for each GLOBAL assembly (ie: DLL) file, sorted by `json_data.assemblies[n].hash64`:
20 = hash64
------------ for each LOCAL assembly (ie: DLL) file, sorted by `json_data.assemblies[n].blob_idx`:
DataSize = DLL data
------------

======
where:
======
* the current assembly store is identified by:
    `json_data.stores[i]`
* LOCAL only includes assemblies in the current assembly store, indicated by:
    `json_data.stores[i].store_id` === `json_data.assemblies[n].store_id`
* GLOBAL includes all items in the `json_data.assemblies` list of assemblies
* `json_data.stores[i].lec` is a count of all LOCAL assemblies
* `json_data.stores[i].gec` is a count of all GLOBAL assemblies,
  which includes all LOCAL assemblies

=============================================
primary vs. architecture-specific blob files:
=============================================
* the primary assembly store is identified by:
    `json_data.stores[i].store_id` === `0`
* only the primary "assemblies.blob" file includes:
  - hash32
  - hash64
* architecture-specific blob files exclude these blocks

======
notes:
======
* `json_data.assemblies[n].hash32` and
  `json_data.assemblies[n].hash64`
  - these fields are strings that contain hex-encoded values (ex: "0x12345")
  - hash64 values are too large for Number, and require BigInt
  - sorting on these fields is performed on the string representation,
    rather than numerical..
    * is this correct?
    * as a test, I changed:
        const sortedHash32 = [...assembly_data].sort((a, b) => (a.hash32 > b.hash32 ? 1 : -1));
        const sortedHash64 = [...assembly_data].sort((a, b) => (a.hash64 > b.hash64 ? 1 : -1));
      to:
        const sortedHash32 = [...assembly_data].sort((a, b) => (BigInt(a.hash32) > BigInt(b.hash32) ? 1 : -1));
        const sortedHash64 = [...assembly_data].sort((a, b) => (BigInt(a.hash64) > BigInt(b.hash64) ? 1 : -1));
      but:
        for both test cases, "pack" doesn't currently work
